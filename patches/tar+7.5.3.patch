diff --git a/node_modules/tar/dist/commonjs/unpack.js b/node_modules/tar/dist/commonjs/unpack.js
index dea24ed..e7280d0 100644
--- a/node_modules/tar/dist/commonjs/unpack.js
+++ b/node_modules/tar/dist/commonjs/unpack.js
@@ -125,6 +125,17 @@ const unlinkFileSync = (path) => {
 const uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a
     : b !== undefined && b === b >>> 0 ? b
         : c;
+// Helper function to check if a path is within the extraction root (cwd)
+// This prevents hardlinks and symlinks from escaping the extraction directory
+const isPathWithinRoot = (targetPath, rootPath) => {
+    const normalizedTarget = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(targetPath));
+    const normalizedRoot = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(rootPath));
+    // On Windows, ensure case-insensitive comparison
+    const target = isWindows ? normalizedTarget.toLowerCase() : normalizedTarget;
+    const root = isWindows ? normalizedRoot.toLowerCase() : normalizedRoot;
+    // Check if target starts with root + path separator (or equals root)
+    return target === root || target.startsWith(root + node_path_1.default.sep) || target.startsWith(root + '/');
+};
 class Unpack extends parse_js_1.Parser {
     [ENDED] = false;
     [CHECKED_CWD] = false;
@@ -539,10 +550,85 @@ class Unpack extends parse_js_1.Parser {
         entry.resume();
     }
     [SYMLINK](entry, done) {
-        this[LINK](entry, String(entry.linkpath), 'symlink', done);
+        const rawLinkpath = String(entry.linkpath);
+        let linkpath = rawLinkpath;
+        
+        // SECURITY FIX: Validate symlink targets when preservePaths is false
+        // This prevents creating symlinks pointing to absolute paths or escaping the extraction root
+        if (!this.preservePaths) {
+            // Reject absolute paths
+            if (node_path_1.default.isAbsolute(rawLinkpath)) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target must be relative when preservePaths is false', {
+                    entry,
+                    linkpath: rawLinkpath,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            // Reject paths with .. components that would escape
+            const normalizedLinkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(rawLinkpath);
+            const linkparts = normalizedLinkpath.split('/');
+            if (linkparts.includes('..') ||
+                /* c8 ignore next */
+                (isWindows && /^[a-z]:\.\.$/i.test(linkparts[0] ?? ''))) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target contains path traversal', {
+                    entry,
+                    linkpath: rawLinkpath,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            // For symlinks, resolve relative to the entry's directory to check if it escapes
+            // We don't actually create the resolved path for the symlink (symlinks are relative),
+            // but we validate that if resolved, it would stay within the extraction root
+            const entryDir = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.dirname(String(entry.absolute)));
+            const resolvedLinkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(entryDir, normalizedLinkpath));
+            
+            // Ensure the resolved symlink target is within the extraction root
+            if (!isPathWithinRoot(resolvedLinkpath, this.cwd)) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target would escape extraction root', {
+                    entry,
+                    linkpath: rawLinkpath,
+                    resolvedLinkpath,
+                    cwd: this.cwd,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            linkpath = normalizedLinkpath;
+        }
+        
+        this[LINK](entry, linkpath, 'symlink', done);
     }
     [HARDLINK](entry, done) {
-        const linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, String(entry.linkpath)));
+        const rawLinkpath = String(entry.linkpath);
+        // Resolve the linkpath. If it's absolute, path.resolve ignores this.cwd
+        const linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, rawLinkpath));
+        
+        // SECURITY FIX: Validate that the hardlink target is within the extraction root
+        // This prevents creating hardlinks to files outside the extraction directory
+        if (!this.preservePaths && !isPathWithinRoot(linkpath, this.cwd)) {
+            this.warn('TAR_ENTRY_ERROR', 'hardlink target escapes extraction root', {
+                entry,
+                linkpath: rawLinkpath,
+                resolvedLinkpath: linkpath,
+                cwd: this.cwd,
+            });
+            this[UNPEND]();
+            entry.resume();
+            done();
+            return;
+        }
+        
         this[LINK](entry, linkpath, 'link', done);
     }
     [PEND]() {
diff --git a/node_modules/tar/dist/esm/unpack.js b/node_modules/tar/dist/esm/unpack.js
index 2327487..e537833 100644
--- a/node_modules/tar/dist/esm/unpack.js
+++ b/node_modules/tar/dist/esm/unpack.js
@@ -86,6 +86,17 @@ const unlinkFileSync = (path) => {
 const uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a
     : b !== undefined && b === b >>> 0 ? b
         : c;
+// Helper function to check if a path is within the extraction root (cwd)
+// This prevents hardlinks and symlinks from escaping the extraction directory
+const isPathWithinRoot = (targetPath, rootPath) => {
+    const normalizedTarget = normalizeWindowsPath(path.resolve(targetPath));
+    const normalizedRoot = normalizeWindowsPath(path.resolve(rootPath));
+    // On Windows, ensure case-insensitive comparison
+    const target = isWindows ? normalizedTarget.toLowerCase() : normalizedTarget;
+    const root = isWindows ? normalizedRoot.toLowerCase() : normalizedRoot;
+    // Check if target starts with root + path separator (or equals root)
+    return target === root || target.startsWith(root + path.sep) || target.startsWith(root + '/');
+};
 export class Unpack extends Parser {
     [ENDED] = false;
     [CHECKED_CWD] = false;
@@ -500,10 +511,85 @@ export class Unpack extends Parser {
         entry.resume();
     }
     [SYMLINK](entry, done) {
-        this[LINK](entry, String(entry.linkpath), 'symlink', done);
+        const rawLinkpath = String(entry.linkpath);
+        let linkpath = rawLinkpath;
+        
+        // SECURITY FIX: Validate symlink targets when preservePaths is false
+        // This prevents creating symlinks pointing to absolute paths or escaping the extraction root
+        if (!this.preservePaths) {
+            // Reject absolute paths
+            if (path.isAbsolute(rawLinkpath)) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target must be relative when preservePaths is false', {
+                    entry,
+                    linkpath: rawLinkpath,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            // Reject paths with .. components that would escape
+            const normalizedLinkpath = normalizeWindowsPath(rawLinkpath);
+            const linkparts = normalizedLinkpath.split('/');
+            if (linkparts.includes('..') ||
+                /* c8 ignore next */
+                (isWindows && /^[a-z]:\.\.$/i.test(linkparts[0] ?? ''))) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target contains path traversal', {
+                    entry,
+                    linkpath: rawLinkpath,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            // For symlinks, resolve relative to the entry's directory to check if it escapes
+            // We don't actually create the resolved path for the symlink (symlinks are relative),
+            // but we validate that if resolved, it would stay within the extraction root
+            const entryDir = normalizeWindowsPath(path.dirname(String(entry.absolute)));
+            const resolvedLinkpath = normalizeWindowsPath(path.resolve(entryDir, normalizedLinkpath));
+            
+            // Ensure the resolved symlink target is within the extraction root
+            if (!isPathWithinRoot(resolvedLinkpath, this.cwd)) {
+                this.warn('TAR_ENTRY_ERROR', 'symlink target would escape extraction root', {
+                    entry,
+                    linkpath: rawLinkpath,
+                    resolvedLinkpath,
+                    cwd: this.cwd,
+                });
+                this[UNPEND]();
+                entry.resume();
+                done();
+                return;
+            }
+            
+            linkpath = normalizedLinkpath;
+        }
+        
+        this[LINK](entry, linkpath, 'symlink', done);
     }
     [HARDLINK](entry, done) {
-        const linkpath = normalizeWindowsPath(path.resolve(this.cwd, String(entry.linkpath)));
+        const rawLinkpath = String(entry.linkpath);
+        // Resolve the linkpath. If it's absolute, path.resolve ignores this.cwd
+        const linkpath = normalizeWindowsPath(path.resolve(this.cwd, rawLinkpath));
+        
+        // SECURITY FIX: Validate that the hardlink target is within the extraction root
+        // This prevents creating hardlinks to files outside the extraction directory
+        if (!this.preservePaths && !isPathWithinRoot(linkpath, this.cwd)) {
+            this.warn('TAR_ENTRY_ERROR', 'hardlink target escapes extraction root', {
+                entry,
+                linkpath: rawLinkpath,
+                resolvedLinkpath: linkpath,
+                cwd: this.cwd,
+            });
+            this[UNPEND]();
+            entry.resume();
+            done();
+            return;
+        }
+        
         this[LINK](entry, linkpath, 'link', done);
     }
     [PEND]() {
